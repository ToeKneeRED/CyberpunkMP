// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace CyberpunkSdk.Internal
{
    public unsafe abstract partial class IAttachmentComponent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_IAttachmentComponent;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN20IAttachmentComponentC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IAttachmentComponent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IAttachmentComponent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IAttachmentComponent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IAttachmentComponent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IAttachmentComponent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IAttachmentComponentInternal(native.ToPointer(), skipVTables);
        }

        internal static IAttachmentComponent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IAttachmentComponent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IAttachmentComponent __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (IAttachmentComponent)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static IAttachmentComponent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IAttachmentComponentInternal(native, skipVTables);
        }

        protected IAttachmentComponent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        internal IAttachmentComponent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IAttachmentComponent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IAttachmentComponent");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract ulong Parent
        {
            get;
        }

        public abstract ulong Slot
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IAttachmentComponent()
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IAttachmentComponent.__GetInstance(__instance);
            __target.Dispose(disposing: true, callNativeDtor: true);
        }

        // uint64_t GetParent() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr _GetParentDelegateInstance;

        private static ulong _GetParentDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IAttachmentComponent.__GetInstance(__instance);
            var ___ret = __target.Parent;
            return ___ret;
        }

        // uint64_t GetSlot() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr _GetSlotDelegateInstance;

        private static ulong _GetSlotDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IAttachmentComponent.__GetInstance(__instance);
            var ___ret = __target.Slot;
            return ___ret;
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[3];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _GetParentDelegateInstance += _GetParentDelegateHook;
                _GetSlotDelegateInstance += _GetSlotDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetParentDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetSlotDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 2);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 2);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            ManagedVTables[0][3] = Thunks[2];
                            VTables.Methods[0] = new Delegate[6];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class IAttachmentComponentInternal : global::CyberpunkSdk.Internal.IAttachmentComponent, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IAttachmentComponentInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal IAttachmentComponentInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override ulong Parent
        {
            get
            {
                var ___GetParentDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr>(0, 2);
                var ___ret = ___GetParentDelegate(__Instance);
                return ___ret;
            }
        }

        public override ulong Slot
        {
            get
            {
                var ___GetSlotDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr>(0, 3);
                var ___ret = ___GetSlotDelegate(__Instance);
                return ___ret;
            }
        }
    }

    public unsafe abstract partial class IBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_IBuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IBufferC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IBufferC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IBuffer6CreateEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Create();

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IBuffer7ReleaseEPS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Release(__IntPtr Buffer);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IBuffer> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IBuffer>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IBuffer managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IBuffer managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IBufferInternal(native.ToPointer(), skipVTables);
        }

        internal static IBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IBuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IBuffer __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (IBuffer)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static IBuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IBufferInternal(native, skipVTables);
        }

        protected IBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        protected IBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IBuffer");
        }

        protected IBuffer(global::CyberpunkSdk.Internal.IBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IBuffer");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract string ReadString();

        public abstract sbyte ReadInt8();

        public abstract byte ReadUint8();

        public abstract short ReadInt16();

        public abstract ushort ReadUint16();

        public abstract int ReadInt32();

        public abstract uint ReadUint32();

        public abstract long ReadInt64();

        public abstract ulong ReadUint64();

        public abstract ulong ReadVarInt();

        public abstract float ReadFloat();

        public abstract double ReadDouble();

        public abstract bool ReadBool();

        public abstract void WriteString(string Str);

        public abstract void WriteInt8(sbyte Data);

        public abstract void WriteUint8(byte Data);

        public abstract void WriteInt16(short Data);

        public abstract void WriteUint16(ushort Data);

        public abstract void WriteInt32(int Data);

        public abstract void WriteUint32(uint Data);

        public abstract void WriteInt64(long Data);

        public abstract void WriteUint64(ulong Data);

        public abstract void WriteVarInt(ulong Data);

        public abstract void WriteFloat(float Data);

        public abstract void WriteDouble(int Data);

        public abstract void WriteBool(bool Data);

        public static global::CyberpunkSdk.Internal.IBuffer Create()
        {
            var ___ret = __Internal.Create();
            var __result0 = global::CyberpunkSdk.Internal.IBuffer.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        public static void Release(global::CyberpunkSdk.Internal.IBuffer Buffer)
        {
            var __arg0 = Buffer is null ? __IntPtr.Zero : Buffer.__Instance;
            __Internal.Release(__arg0);
        }

        #region Virtual table interop

        // virtual ~IBuffer()
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.Dispose(disposing: true, callNativeDtor: true);
        }

        // char* ReadString() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _ReadStringDelegateInstance;

        private static __IntPtr _ReadStringDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadString();
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // int8_t ReadInt8() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_sbyte___IntPtr _ReadInt8DelegateInstance;

        private static sbyte _ReadInt8DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadInt8();
            return ___ret;
        }

        // uint8_t ReadUint8() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_byte___IntPtr _ReadUint8DelegateInstance;

        private static byte _ReadUint8DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadUint8();
            return ___ret;
        }

        // int16_t ReadInt16() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_short___IntPtr _ReadInt16DelegateInstance;

        private static short _ReadInt16DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadInt16();
            return ___ret;
        }

        // uint16_t ReadUint16() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr _ReadUint16DelegateInstance;

        private static ushort _ReadUint16DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadUint16();
            return ___ret;
        }

        // int32_t ReadInt32() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_int___IntPtr _ReadInt32DelegateInstance;

        private static int _ReadInt32DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadInt32();
            return ___ret;
        }

        // uint32_t ReadUint32() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr _ReadUint32DelegateInstance;

        private static uint _ReadUint32DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadUint32();
            return ___ret;
        }

        // int64_t ReadInt64() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_long___IntPtr _ReadInt64DelegateInstance;

        private static long _ReadInt64DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadInt64();
            return ___ret;
        }

        // uint64_t ReadUint64() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr _ReadUint64DelegateInstance;

        private static ulong _ReadUint64DelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadUint64();
            return ___ret;
        }

        // uint64_t ReadVarInt() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr _ReadVarIntDelegateInstance;

        private static ulong _ReadVarIntDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadVarInt();
            return ___ret;
        }

        // float ReadFloat() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_float___IntPtr _ReadFloatDelegateInstance;

        private static float _ReadFloatDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadFloat();
            return ___ret;
        }

        // double ReadDouble() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_double___IntPtr _ReadDoubleDelegateInstance;

        private static double _ReadDoubleDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadDouble();
            return ___ret;
        }

        // bool ReadBool() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_bool___IntPtr _ReadBoolDelegateInstance;

        private static bool _ReadBoolDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            var ___ret = __target.ReadBool();
            return ___ret;
        }

        // void WriteString(const char* Str) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8 _WriteStringDelegateInstance;

        private static void _WriteStringDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string Str)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteString(Str);
        }

        // void WriteInt8(int8_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_sbyte _WriteInt8DelegateInstance;

        private static void _WriteInt8DelegateHook(__IntPtr __instance, sbyte Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteInt8(Data);
        }

        // void WriteUint8(uint8_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_byte _WriteUint8DelegateInstance;

        private static void _WriteUint8DelegateHook(__IntPtr __instance, byte Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteUint8(Data);
        }

        // void WriteInt16(int16_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_short _WriteInt16DelegateInstance;

        private static void _WriteInt16DelegateHook(__IntPtr __instance, short Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteInt16(Data);
        }

        // void WriteUint16(uint16_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ushort _WriteUint16DelegateInstance;

        private static void _WriteUint16DelegateHook(__IntPtr __instance, ushort Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteUint16(Data);
        }

        // void WriteInt32(int32_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_int _WriteInt32DelegateInstance;

        private static void _WriteInt32DelegateHook(__IntPtr __instance, int Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteInt32(Data);
        }

        // void WriteUint32(uint32_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_uint _WriteUint32DelegateInstance;

        private static void _WriteUint32DelegateHook(__IntPtr __instance, uint Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteUint32(Data);
        }

        // void WriteInt64(int64_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_long _WriteInt64DelegateInstance;

        private static void _WriteInt64DelegateHook(__IntPtr __instance, long Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteInt64(Data);
        }

        // void WriteUint64(uint64_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong _WriteUint64DelegateInstance;

        private static void _WriteUint64DelegateHook(__IntPtr __instance, ulong Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteUint64(Data);
        }

        // void WriteVarInt(uint64_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong _WriteVarIntDelegateInstance;

        private static void _WriteVarIntDelegateHook(__IntPtr __instance, ulong Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteVarInt(Data);
        }

        // void WriteFloat(float Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_float _WriteFloatDelegateInstance;

        private static void _WriteFloatDelegateHook(__IntPtr __instance, float Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteFloat(Data);
        }

        // void WriteDouble(int32_t Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_int _WriteDoubleDelegateInstance;

        private static void _WriteDoubleDelegateHook(__IntPtr __instance, int Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteDouble(Data);
        }

        // void WriteBool(bool Data) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_bool _WriteBoolDelegateInstance;

        private static void _WriteBoolDelegateHook(__IntPtr __instance, bool Data)
        {
            var __target = global::CyberpunkSdk.Internal.IBuffer.__GetInstance(__instance);
            __target.WriteBool(Data);
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[27];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _ReadStringDelegateInstance += _ReadStringDelegateHook;
                _ReadInt8DelegateInstance += _ReadInt8DelegateHook;
                _ReadUint8DelegateInstance += _ReadUint8DelegateHook;
                _ReadInt16DelegateInstance += _ReadInt16DelegateHook;
                _ReadUint16DelegateInstance += _ReadUint16DelegateHook;
                _ReadInt32DelegateInstance += _ReadInt32DelegateHook;
                _ReadUint32DelegateInstance += _ReadUint32DelegateHook;
                _ReadInt64DelegateInstance += _ReadInt64DelegateHook;
                _ReadUint64DelegateInstance += _ReadUint64DelegateHook;
                _ReadVarIntDelegateInstance += _ReadVarIntDelegateHook;
                _ReadFloatDelegateInstance += _ReadFloatDelegateHook;
                _ReadDoubleDelegateInstance += _ReadDoubleDelegateHook;
                _ReadBoolDelegateInstance += _ReadBoolDelegateHook;
                _WriteStringDelegateInstance += _WriteStringDelegateHook;
                _WriteInt8DelegateInstance += _WriteInt8DelegateHook;
                _WriteUint8DelegateInstance += _WriteUint8DelegateHook;
                _WriteInt16DelegateInstance += _WriteInt16DelegateHook;
                _WriteUint16DelegateInstance += _WriteUint16DelegateHook;
                _WriteInt32DelegateInstance += _WriteInt32DelegateHook;
                _WriteUint32DelegateInstance += _WriteUint32DelegateHook;
                _WriteInt64DelegateInstance += _WriteInt64DelegateHook;
                _WriteUint64DelegateInstance += _WriteUint64DelegateHook;
                _WriteVarIntDelegateInstance += _WriteVarIntDelegateHook;
                _WriteFloatDelegateInstance += _WriteFloatDelegateHook;
                _WriteDoubleDelegateInstance += _WriteDoubleDelegateHook;
                _WriteBoolDelegateInstance += _WriteBoolDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_ReadStringDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ReadInt8DelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ReadUint8DelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ReadInt16DelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ReadUint16DelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ReadInt32DelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_ReadUint32DelegateInstance);
                Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ReadInt64DelegateInstance);
                Thunks[9] = Marshal.GetFunctionPointerForDelegate(_ReadUint64DelegateInstance);
                Thunks[10] = Marshal.GetFunctionPointerForDelegate(_ReadVarIntDelegateInstance);
                Thunks[11] = Marshal.GetFunctionPointerForDelegate(_ReadFloatDelegateInstance);
                Thunks[12] = Marshal.GetFunctionPointerForDelegate(_ReadDoubleDelegateInstance);
                Thunks[13] = Marshal.GetFunctionPointerForDelegate(_ReadBoolDelegateInstance);
                Thunks[14] = Marshal.GetFunctionPointerForDelegate(_WriteStringDelegateInstance);
                Thunks[15] = Marshal.GetFunctionPointerForDelegate(_WriteInt8DelegateInstance);
                Thunks[16] = Marshal.GetFunctionPointerForDelegate(_WriteUint8DelegateInstance);
                Thunks[17] = Marshal.GetFunctionPointerForDelegate(_WriteInt16DelegateInstance);
                Thunks[18] = Marshal.GetFunctionPointerForDelegate(_WriteUint16DelegateInstance);
                Thunks[19] = Marshal.GetFunctionPointerForDelegate(_WriteInt32DelegateInstance);
                Thunks[20] = Marshal.GetFunctionPointerForDelegate(_WriteUint32DelegateInstance);
                Thunks[21] = Marshal.GetFunctionPointerForDelegate(_WriteInt64DelegateInstance);
                Thunks[22] = Marshal.GetFunctionPointerForDelegate(_WriteUint64DelegateInstance);
                Thunks[23] = Marshal.GetFunctionPointerForDelegate(_WriteVarIntDelegateInstance);
                Thunks[24] = Marshal.GetFunctionPointerForDelegate(_WriteFloatDelegateInstance);
                Thunks[25] = Marshal.GetFunctionPointerForDelegate(_WriteDoubleDelegateInstance);
                Thunks[26] = Marshal.GetFunctionPointerForDelegate(_WriteBoolDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 30, 2);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 30, 2);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            ManagedVTables[0][3] = Thunks[2];
                            ManagedVTables[0][4] = Thunks[3];
                            ManagedVTables[0][5] = Thunks[4];
                            ManagedVTables[0][6] = Thunks[5];
                            ManagedVTables[0][7] = Thunks[6];
                            ManagedVTables[0][8] = Thunks[7];
                            ManagedVTables[0][9] = Thunks[8];
                            ManagedVTables[0][10] = Thunks[9];
                            ManagedVTables[0][11] = Thunks[10];
                            ManagedVTables[0][12] = Thunks[11];
                            ManagedVTables[0][13] = Thunks[12];
                            ManagedVTables[0][14] = Thunks[13];
                            ManagedVTables[0][15] = Thunks[14];
                            ManagedVTables[0][16] = Thunks[15];
                            ManagedVTables[0][17] = Thunks[16];
                            ManagedVTables[0][18] = Thunks[17];
                            ManagedVTables[0][19] = Thunks[18];
                            ManagedVTables[0][20] = Thunks[19];
                            ManagedVTables[0][21] = Thunks[20];
                            ManagedVTables[0][22] = Thunks[21];
                            ManagedVTables[0][23] = Thunks[22];
                            ManagedVTables[0][24] = Thunks[23];
                            ManagedVTables[0][25] = Thunks[24];
                            ManagedVTables[0][26] = Thunks[25];
                            ManagedVTables[0][27] = Thunks[26];
                            VTables.Methods[0] = new Delegate[30];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class IBufferInternal : global::CyberpunkSdk.Internal.IBuffer, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IBufferInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal IBufferInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override string ReadString()
        {
            var ___ReadStringDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 2);
            var ___ret = ___ReadStringDelegate(__Instance);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public override sbyte ReadInt8()
        {
            var ___ReadInt8Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_sbyte___IntPtr>(0, 3);
            var ___ret = ___ReadInt8Delegate(__Instance);
            return ___ret;
        }

        public override byte ReadUint8()
        {
            var ___ReadUint8Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_byte___IntPtr>(0, 4);
            var ___ret = ___ReadUint8Delegate(__Instance);
            return ___ret;
        }

        public override short ReadInt16()
        {
            var ___ReadInt16Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_short___IntPtr>(0, 5);
            var ___ret = ___ReadInt16Delegate(__Instance);
            return ___ret;
        }

        public override ushort ReadUint16()
        {
            var ___ReadUint16Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr>(0, 6);
            var ___ret = ___ReadUint16Delegate(__Instance);
            return ___ret;
        }

        public override int ReadInt32()
        {
            var ___ReadInt32Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_int___IntPtr>(0, 7);
            var ___ret = ___ReadInt32Delegate(__Instance);
            return ___ret;
        }

        public override uint ReadUint32()
        {
            var ___ReadUint32Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr>(0, 8);
            var ___ret = ___ReadUint32Delegate(__Instance);
            return ___ret;
        }

        public override long ReadInt64()
        {
            var ___ReadInt64Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_long___IntPtr>(0, 9);
            var ___ret = ___ReadInt64Delegate(__Instance);
            return ___ret;
        }

        public override ulong ReadUint64()
        {
            var ___ReadUint64Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr>(0, 10);
            var ___ret = ___ReadUint64Delegate(__Instance);
            return ___ret;
        }

        public override ulong ReadVarInt()
        {
            var ___ReadVarIntDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr>(0, 11);
            var ___ret = ___ReadVarIntDelegate(__Instance);
            return ___ret;
        }

        public override float ReadFloat()
        {
            var ___ReadFloatDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_float___IntPtr>(0, 12);
            var ___ret = ___ReadFloatDelegate(__Instance);
            return ___ret;
        }

        public override double ReadDouble()
        {
            var ___ReadDoubleDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_double___IntPtr>(0, 13);
            var ___ret = ___ReadDoubleDelegate(__Instance);
            return ___ret;
        }

        public override bool ReadBool()
        {
            var ___ReadBoolDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_bool___IntPtr>(0, 14);
            var ___ret = ___ReadBoolDelegate(__Instance);
            return ___ret;
        }

        public override void WriteString(string Str)
        {
            var ___WriteStringDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8>(0, 15);
            ___WriteStringDelegate(__Instance, Str);
        }

        public override void WriteInt8(sbyte Data)
        {
            var ___WriteInt8Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_sbyte>(0, 16);
            ___WriteInt8Delegate(__Instance, Data);
        }

        public override void WriteUint8(byte Data)
        {
            var ___WriteUint8Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_byte>(0, 17);
            ___WriteUint8Delegate(__Instance, Data);
        }

        public override void WriteInt16(short Data)
        {
            var ___WriteInt16Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_short>(0, 18);
            ___WriteInt16Delegate(__Instance, Data);
        }

        public override void WriteUint16(ushort Data)
        {
            var ___WriteUint16Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ushort>(0, 19);
            ___WriteUint16Delegate(__Instance, Data);
        }

        public override void WriteInt32(int Data)
        {
            var ___WriteInt32Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_int>(0, 20);
            ___WriteInt32Delegate(__Instance, Data);
        }

        public override void WriteUint32(uint Data)
        {
            var ___WriteUint32Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_uint>(0, 21);
            ___WriteUint32Delegate(__Instance, Data);
        }

        public override void WriteInt64(long Data)
        {
            var ___WriteInt64Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_long>(0, 22);
            ___WriteInt64Delegate(__Instance, Data);
        }

        public override void WriteUint64(ulong Data)
        {
            var ___WriteUint64Delegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong>(0, 23);
            ___WriteUint64Delegate(__Instance, Data);
        }

        public override void WriteVarInt(ulong Data)
        {
            var ___WriteVarIntDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong>(0, 24);
            ___WriteVarIntDelegate(__Instance, Data);
        }

        public override void WriteFloat(float Data)
        {
            var ___WriteFloatDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_float>(0, 25);
            ___WriteFloatDelegate(__Instance, Data);
        }

        public override void WriteDouble(int Data)
        {
            var ___WriteDoubleDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_int>(0, 26);
            ___WriteDoubleDelegate(__Instance, Data);
        }

        public override void WriteBool(bool Data)
        {
            var ___WriteBoolDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_bool>(0, 27);
            ___WriteBoolDelegate(__Instance, Data);
        }
    }

    public unsafe abstract partial class IConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_IConfig;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IConfigC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IConfigC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IConfig3GetEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IConfigInternal(native.ToPointer(), skipVTables);
        }

        internal static IConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IConfig __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (IConfig)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static IConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IConfigInternal(native, skipVTables);
        }

        protected IConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        protected IConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IConfig");
        }

        protected IConfig(global::CyberpunkSdk.Internal.IConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IConfig");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static global::CyberpunkSdk.Internal.IConfig Get()
        {
            var ___ret = __Internal.Get();
            var __result0 = global::CyberpunkSdk.Internal.IConfig.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public abstract string Name
        {
            get;
        }

        public abstract string Description
        {
            get;
        }

        public abstract string ApiKey
        {
            get;
        }

        public abstract string IconUrl
        {
            get;
        }

        public abstract string Tags
        {
            get;
        }

        public abstract string Password
        {
            get;
        }

        public abstract ushort MaxPlayer
        {
            get;
        }

        public abstract ushort Port
        {
            get;
        }

        public abstract ushort WebPort
        {
            get;
        }

        public abstract ushort TickRate
        {
            get;
        }

        public abstract ushort UpdateRate
        {
            get;
        }

        public abstract bool Public
        {
            get;
        }

        #region Virtual table interop

        // char* GetName() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetNameDelegateInstance;

        private static __IntPtr _GetNameDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.Name;
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // char* GetDescription() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetDescriptionDelegateInstance;

        private static __IntPtr _GetDescriptionDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.Description;
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // char* GetApiKey() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetApiKeyDelegateInstance;

        private static __IntPtr _GetApiKeyDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.ApiKey;
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // char* GetIconUrl() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetIconUrlDelegateInstance;

        private static __IntPtr _GetIconUrlDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.IconUrl;
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // char* GetTags() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetTagsDelegateInstance;

        private static __IntPtr _GetTagsDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.Tags;
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // char* GetPassword() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetPasswordDelegateInstance;

        private static __IntPtr _GetPasswordDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.Password;
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // uint16_t GetMaxPlayer() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr _GetMaxPlayerDelegateInstance;

        private static ushort _GetMaxPlayerDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.MaxPlayer;
            return ___ret;
        }

        // uint16_t GetPort() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr _GetPortDelegateInstance;

        private static ushort _GetPortDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.Port;
            return ___ret;
        }

        // uint16_t GetWebPort() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr _GetWebPortDelegateInstance;

        private static ushort _GetWebPortDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.WebPort;
            return ___ret;
        }

        // uint16_t GetTickRate() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr _GetTickRateDelegateInstance;

        private static ushort _GetTickRateDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.TickRate;
            return ___ret;
        }

        // uint16_t GetUpdateRate() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr _GetUpdateRateDelegateInstance;

        private static ushort _GetUpdateRateDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.UpdateRate;
            return ___ret;
        }

        // bool GetPublic() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_bool___IntPtr _GetPublicDelegateInstance;

        private static bool _GetPublicDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IConfig.__GetInstance(__instance);
            var ___ret = __target.Public;
            return ___ret;
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[12];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _GetDescriptionDelegateInstance += _GetDescriptionDelegateHook;
                _GetApiKeyDelegateInstance += _GetApiKeyDelegateHook;
                _GetIconUrlDelegateInstance += _GetIconUrlDelegateHook;
                _GetTagsDelegateInstance += _GetTagsDelegateHook;
                _GetPasswordDelegateInstance += _GetPasswordDelegateHook;
                _GetMaxPlayerDelegateInstance += _GetMaxPlayerDelegateHook;
                _GetPortDelegateInstance += _GetPortDelegateHook;
                _GetWebPortDelegateInstance += _GetWebPortDelegateHook;
                _GetTickRateDelegateInstance += _GetTickRateDelegateHook;
                _GetUpdateRateDelegateInstance += _GetUpdateRateDelegateHook;
                _GetPublicDelegateInstance += _GetPublicDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetDescriptionDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetApiKeyDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetIconUrlDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetTagsDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetPasswordDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetMaxPlayerDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetPortDelegateInstance);
                Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetWebPortDelegateInstance);
                Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetTickRateDelegateInstance);
                Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetUpdateRateDelegateInstance);
                Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetPublicDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 14, 2);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            ManagedVTables[0][6] = Thunks[6];
                            ManagedVTables[0][7] = Thunks[7];
                            ManagedVTables[0][8] = Thunks[8];
                            ManagedVTables[0][9] = Thunks[9];
                            ManagedVTables[0][10] = Thunks[10];
                            ManagedVTables[0][11] = Thunks[11];
                            VTables.Methods[0] = new Delegate[14];
                            if (destructorOnly)
                                return VTables;
                        }
                    }
                }

                *(IntPtr**)(instance + 0) = ManagedVTables[0];
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class IConfigInternal : global::CyberpunkSdk.Internal.IConfig, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IConfigInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal IConfigInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override string Name
        {
            get
            {
                var ___GetNameDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 0);
                var ___ret = ___GetNameDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        public override string Description
        {
            get
            {
                var ___GetDescriptionDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var ___ret = ___GetDescriptionDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        public override string ApiKey
        {
            get
            {
                var ___GetApiKeyDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 2);
                var ___ret = ___GetApiKeyDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        public override string IconUrl
        {
            get
            {
                var ___GetIconUrlDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 3);
                var ___ret = ___GetIconUrlDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        public override string Tags
        {
            get
            {
                var ___GetTagsDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 4);
                var ___ret = ___GetTagsDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        public override string Password
        {
            get
            {
                var ___GetPasswordDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 5);
                var ___ret = ___GetPasswordDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        public override ushort MaxPlayer
        {
            get
            {
                var ___GetMaxPlayerDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr>(0, 6);
                var ___ret = ___GetMaxPlayerDelegate(__Instance);
                return ___ret;
            }
        }

        public override ushort Port
        {
            get
            {
                var ___GetPortDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr>(0, 7);
                var ___ret = ___GetPortDelegate(__Instance);
                return ___ret;
            }
        }

        public override ushort WebPort
        {
            get
            {
                var ___GetWebPortDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr>(0, 8);
                var ___ret = ___GetWebPortDelegate(__Instance);
                return ___ret;
            }
        }

        public override ushort TickRate
        {
            get
            {
                var ___GetTickRateDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr>(0, 9);
                var ___ret = ___GetTickRateDelegate(__Instance);
                return ___ret;
            }
        }

        public override ushort UpdateRate
        {
            get
            {
                var ___GetUpdateRateDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ushort___IntPtr>(0, 10);
                var ___ret = ___GetUpdateRateDelegate(__Instance);
                return ___ret;
            }
        }

        public override bool Public
        {
            get
            {
                var ___GetPublicDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_bool___IntPtr>(0, 11);
                var ___ret = ___GetPublicDelegate(__Instance);
                return ___ret;
            }
        }
    }

    public unsafe abstract partial class ILogger : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_ILogger;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7ILoggerC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7ILoggerC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7ILogger3GetEPKc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string aName);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.ILogger> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.ILogger>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.ILogger managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.ILogger managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ILogger __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ILoggerInternal(native.ToPointer(), skipVTables);
        }

        internal static ILogger __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ILogger)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ILogger __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (ILogger)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static ILogger __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ILoggerInternal(native, skipVTables);
        }

        protected ILogger(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        protected ILogger()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.ILogger.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.ILogger");
        }

        protected ILogger(global::CyberpunkSdk.Internal.ILogger _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.ILogger.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.ILogger");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Debug(string aMessage);

        public abstract void Info(string aMessage);

        public abstract void Warn(string aMessage);

        public abstract void Error(string aMessage);

        public static global::CyberpunkSdk.Internal.ILogger Get(string aName)
        {
            var ___ret = __Internal.Get(aName);
            var __result0 = global::CyberpunkSdk.Internal.ILogger.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        #region Virtual table interop

        // void Debug(const char* aMessage) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8 _DebugDelegateInstance;

        private static void _DebugDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string aMessage)
        {
            var __target = global::CyberpunkSdk.Internal.ILogger.__GetInstance(__instance);
            __target.Debug(aMessage);
        }

        // void Info(const char* aMessage) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8 _InfoDelegateInstance;

        private static void _InfoDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string aMessage)
        {
            var __target = global::CyberpunkSdk.Internal.ILogger.__GetInstance(__instance);
            __target.Info(aMessage);
        }

        // void Warn(const char* aMessage) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8 _WarnDelegateInstance;

        private static void _WarnDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string aMessage)
        {
            var __target = global::CyberpunkSdk.Internal.ILogger.__GetInstance(__instance);
            __target.Warn(aMessage);
        }

        // void Error(const char* aMessage) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8 _ErrorDelegateInstance;

        private static void _ErrorDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string aMessage)
        {
            var __target = global::CyberpunkSdk.Internal.ILogger.__GetInstance(__instance);
            __target.Error(aMessage);
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[4];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _DebugDelegateInstance += _DebugDelegateHook;
                _InfoDelegateInstance += _InfoDelegateHook;
                _WarnDelegateInstance += _WarnDelegateHook;
                _ErrorDelegateInstance += _ErrorDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_DebugDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_InfoDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_WarnDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ErrorDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 2);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            VTables.Methods[0] = new Delegate[6];
                            if (destructorOnly)
                                return VTables;
                        }
                    }
                }

                *(IntPtr**)(instance + 0) = ManagedVTables[0];
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class ILoggerInternal : global::CyberpunkSdk.Internal.ILogger, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ILoggerInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal ILoggerInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override void Debug(string aMessage)
        {
            var ___DebugDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8>(0, 0);
            ___DebugDelegate(__Instance, aMessage);
        }

        public override void Info(string aMessage)
        {
            var ___InfoDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8>(0, 1);
            ___InfoDelegate(__Instance, aMessage);
        }

        public override void Warn(string aMessage)
        {
            var ___WarnDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8>(0, 2);
            ___WarnDelegate(__Instance, aMessage);
        }

        public override void Error(string aMessage)
        {
            var ___ErrorDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8>(0, 3);
            ___ErrorDelegate(__Instance, aMessage);
        }
    }

    public unsafe partial class Vector3 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float X;
            internal float Y;
            internal float Z;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7Vector3C2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.Vector3> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.Vector3>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.Vector3 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.Vector3 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vector3 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vector3(native.ToPointer(), skipVTables);
        }

        internal static Vector3 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vector3)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vector3 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vector3(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector3(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vector3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vector3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.Vector3.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Vector3(global::CyberpunkSdk.Internal.Vector3 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.Vector3.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::CyberpunkSdk.Internal.Vector3.__Internal*) __Instance) = *((global::CyberpunkSdk.Internal.Vector3.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->Z;
            }

            set
            {
                ((__Internal*)__Instance)->Z = value;
            }
        }
    }

    public unsafe abstract partial class IMovementComponent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_IMovementComponent;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN18IMovementComponentC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IMovementComponent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IMovementComponent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IMovementComponent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IMovementComponent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IMovementComponent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IMovementComponentInternal(native.ToPointer(), skipVTables);
        }

        internal static IMovementComponent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IMovementComponent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IMovementComponent __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (IMovementComponent)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static IMovementComponent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IMovementComponentInternal(native, skipVTables);
        }

        protected IMovementComponent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        protected IMovementComponent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IMovementComponent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IMovementComponent");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract global::CyberpunkSdk.Internal.Vector3 Position
        {
            get;
        }

        public abstract global::CyberpunkSdk.Internal.Vector3 Rotation
        {
            get;
        }

        public abstract float Velocity
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IMovementComponent()
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IMovementComponent.__GetInstance(__instance);
            __target.Dispose(disposing: true, callNativeDtor: true);
        }

        // Vector3 GetPosition() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_CyberpunkSdk_Internal_Vector3___Internal___IntPtr _GetPositionDelegateInstance;

        private static global::CyberpunkSdk.Internal.Vector3.__Internal _GetPositionDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IMovementComponent.__GetInstance(__instance);
            var ___ret = __target.Position;
            if (ReferenceEquals(___ret, null))
                throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
            return *(global::CyberpunkSdk.Internal.Vector3.__Internal*) ___ret.__Instance;
        }

        // Vector3 GetRotation() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_CyberpunkSdk_Internal_Vector3___Internal___IntPtr _GetRotationDelegateInstance;

        private static global::CyberpunkSdk.Internal.Vector3.__Internal _GetRotationDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IMovementComponent.__GetInstance(__instance);
            var ___ret = __target.Rotation;
            if (ReferenceEquals(___ret, null))
                throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
            return *(global::CyberpunkSdk.Internal.Vector3.__Internal*) ___ret.__Instance;
        }

        // float GetVelocity() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_float___IntPtr _GetVelocityDelegateInstance;

        private static float _GetVelocityDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IMovementComponent.__GetInstance(__instance);
            var ___ret = __target.Velocity;
            return ___ret;
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[4];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _GetRotationDelegateInstance += _GetRotationDelegateHook;
                _GetVelocityDelegateInstance += _GetVelocityDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetRotationDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetVelocityDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 2);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 2);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            ManagedVTables[0][3] = Thunks[2];
                            ManagedVTables[0][4] = Thunks[3];
                            VTables.Methods[0] = new Delegate[7];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class IMovementComponentInternal : global::CyberpunkSdk.Internal.IMovementComponent, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IMovementComponentInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal IMovementComponentInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override global::CyberpunkSdk.Internal.Vector3 Position
        {
            get
            {
                var ___GetPositionDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_CyberpunkSdk_Internal_Vector3___Internal___IntPtr>(0, 2);
                var ___ret = ___GetPositionDelegate(__Instance);
                return global::CyberpunkSdk.Internal.Vector3.__CreateInstance(___ret);
            }
        }

        public override global::CyberpunkSdk.Internal.Vector3 Rotation
        {
            get
            {
                var ___GetRotationDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_CyberpunkSdk_Internal_Vector3___Internal___IntPtr>(0, 3);
                var ___ret = ___GetRotationDelegate(__Instance);
                return global::CyberpunkSdk.Internal.Vector3.__CreateInstance(___ret);
            }
        }

        public override float Velocity
        {
            get
            {
                var ___GetVelocityDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_float___IntPtr>(0, 4);
                var ___ret = ___GetVelocityDelegate(__Instance);
                return ___ret;
            }
        }
    }

    public unsafe abstract partial class IPlayer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_IPlayer;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7IPlayerC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IPlayer> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IPlayer>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IPlayer managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IPlayer managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IPlayer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IPlayerInternal(native.ToPointer(), skipVTables);
        }

        internal static IPlayer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IPlayer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IPlayer __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (IPlayer)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static IPlayer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IPlayerInternal(native, skipVTables);
        }

        protected IPlayer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        protected IPlayer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IPlayer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IPlayer");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void SendChat(string From, string Message);

        public abstract void Call(ulong Klass, ulong Function, global::CyberpunkSdk.Internal.IBuffer Arguments);

        public abstract ulong Id
        {
            get;
        }

        public abstract ulong PuppetId
        {
            get;
        }

        public abstract uint ConnectionId
        {
            get;
        }

        public abstract global::CyberpunkSdk.Internal.IMovementComponent MovementComponent
        {
            get;
        }

        public abstract global::CyberpunkSdk.Internal.IAttachmentComponent AttachmentComponent
        {
            get;
        }

        public abstract string Username
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IPlayer()
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            __target.Dispose(disposing: true, callNativeDtor: true);
        }

        // uint64_t GetId() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr _GetIdDelegateInstance;

        private static ulong _GetIdDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            var ___ret = __target.Id;
            return ___ret;
        }

        // uint64_t GetPuppetId() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr _GetPuppetIdDelegateInstance;

        private static ulong _GetPuppetIdDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            var ___ret = __target.PuppetId;
            return ___ret;
        }

        // uint32_t GetConnectionId() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr _GetConnectionIdDelegateInstance;

        private static uint _GetConnectionIdDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            var ___ret = __target.ConnectionId;
            return ___ret;
        }

        // IMovementComponent* GetMovementComponent() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetMovementComponentDelegateInstance;

        private static __IntPtr _GetMovementComponentDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            var ___ret = __target.MovementComponent;
            return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
        }

        // IAttachmentComponent* GetAttachmentComponent() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetAttachmentComponentDelegateInstance;

        private static __IntPtr _GetAttachmentComponentDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            var ___ret = __target.AttachmentComponent;
            return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
        }

        // char* GetUsername() const = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr _GetUsernameDelegateInstance;

        private static __IntPtr _GetUsernameDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            var ___ret = __target.Username;
            var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
            var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
            Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
            Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
            return __bytePtr0;
        }

        // void SendChat(const char* From, const char* Message) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8_string8 _SendChatDelegateInstance;

        private static void _SendChatDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string From, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string Message)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            __target.SendChat(From, Message);
        }

        // void Call(uint64_t Klass, uint64_t Function, IBuffer* Arguments) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong_ulong___IntPtr _CallDelegateInstance;

        private static void _CallDelegateHook(__IntPtr __instance, ulong Klass, ulong Function, __IntPtr Arguments)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayer.__GetInstance(__instance);
            var __result2 = global::CyberpunkSdk.Internal.IBuffer.__GetOrCreateInstance(Arguments, false);
            __target.Call(Klass, Function, __result2);
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[9];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _GetIdDelegateInstance += _GetIdDelegateHook;
                _GetPuppetIdDelegateInstance += _GetPuppetIdDelegateHook;
                _GetConnectionIdDelegateInstance += _GetConnectionIdDelegateHook;
                _GetMovementComponentDelegateInstance += _GetMovementComponentDelegateHook;
                _GetAttachmentComponentDelegateInstance += _GetAttachmentComponentDelegateHook;
                _GetUsernameDelegateInstance += _GetUsernameDelegateHook;
                _SendChatDelegateInstance += _SendChatDelegateHook;
                _CallDelegateInstance += _CallDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetIdDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPuppetIdDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetConnectionIdDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetMovementComponentDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetAttachmentComponentDelegateInstance);
                Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetUsernameDelegateInstance);
                Thunks[7] = Marshal.GetFunctionPointerForDelegate(_SendChatDelegateInstance);
                Thunks[8] = Marshal.GetFunctionPointerForDelegate(_CallDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 2);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 12, 2);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            ManagedVTables[0][3] = Thunks[2];
                            ManagedVTables[0][4] = Thunks[3];
                            ManagedVTables[0][5] = Thunks[4];
                            ManagedVTables[0][6] = Thunks[5];
                            ManagedVTables[0][7] = Thunks[6];
                            ManagedVTables[0][8] = Thunks[7];
                            ManagedVTables[0][9] = Thunks[8];
                            VTables.Methods[0] = new Delegate[12];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class IPlayerInternal : global::CyberpunkSdk.Internal.IPlayer, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IPlayerInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal IPlayerInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override void SendChat(string From, string Message)
        {
            var ___SendChatDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_string8_string8>(0, 8);
            ___SendChatDelegate(__Instance, From, Message);
        }

        public override void Call(ulong Klass, ulong Function, global::CyberpunkSdk.Internal.IBuffer Arguments)
        {
            var ___CallDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong_ulong___IntPtr>(0, 9);
            var __arg2 = Arguments is null ? __IntPtr.Zero : Arguments.__Instance;
            ___CallDelegate(__Instance, Klass, Function, __arg2);
        }

        public override ulong Id
        {
            get
            {
                var ___GetIdDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr>(0, 2);
                var ___ret = ___GetIdDelegate(__Instance);
                return ___ret;
            }
        }

        public override ulong PuppetId
        {
            get
            {
                var ___GetPuppetIdDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_ulong___IntPtr>(0, 3);
                var ___ret = ___GetPuppetIdDelegate(__Instance);
                return ___ret;
            }
        }

        public override uint ConnectionId
        {
            get
            {
                var ___GetConnectionIdDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr>(0, 4);
                var ___ret = ___GetConnectionIdDelegate(__Instance);
                return ___ret;
            }
        }

        public override global::CyberpunkSdk.Internal.IMovementComponent MovementComponent
        {
            get
            {
                var ___GetMovementComponentDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 5);
                var ___ret = ___GetMovementComponentDelegate(__Instance);
                var __result0 = global::CyberpunkSdk.Internal.IMovementComponent.__GetOrCreateInstance(___ret, false);
                return __result0;
            }
        }

        public override global::CyberpunkSdk.Internal.IAttachmentComponent AttachmentComponent
        {
            get
            {
                var ___GetAttachmentComponentDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 6);
                var ___ret = ___GetAttachmentComponentDelegate(__Instance);
                var __result0 = global::CyberpunkSdk.Internal.IAttachmentComponent.__GetOrCreateInstance(___ret, false);
                return __result0;
            }
        }

        public override string Username
        {
            get
            {
                var ___GetUsernameDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr>(0, 7);
                var ___ret = ___GetUsernameDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }
    }

    public unsafe abstract partial class IPlayerManager : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_IPlayerManager;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN14IPlayerManagerC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN14IPlayerManagerC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN14IPlayerManager3GetEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get();
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void PlayerIdHandler(ulong Id);

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IPlayerManager> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IPlayerManager>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IPlayerManager managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IPlayerManager managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IPlayerManager __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IPlayerManagerInternal(native.ToPointer(), skipVTables);
        }

        internal static IPlayerManager __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IPlayerManager)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IPlayerManager __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (IPlayerManager)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static IPlayerManager __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IPlayerManagerInternal(native, skipVTables);
        }

        protected IPlayerManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        protected IPlayerManager()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IPlayerManager.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IPlayerManager");
        }

        protected IPlayerManager(global::CyberpunkSdk.Internal.IPlayerManager _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IPlayerManager.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IPlayerManager");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract global::CyberpunkSdk.Internal.IPlayer GetPlayer(ulong Id);

        public static global::CyberpunkSdk.Internal.IPlayerManager Get()
        {
            var ___ret = __Internal.Get();
            var __result0 = global::CyberpunkSdk.Internal.IPlayerManager.__GetOrCreateInstance(___ret, true);
            return __result0;
        }

        #region Virtual table interop

        // virtual ~IPlayerManager()
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayerManager.__GetInstance(__instance);
            __target.Dispose(disposing: true, callNativeDtor: true);
        }

        // IPlayer* GetPlayer(uint64_t Id) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr_ulong _GetPlayerDelegateInstance;

        private static __IntPtr _GetPlayerDelegateHook(__IntPtr __instance, ulong Id)
        {
            var __target = global::CyberpunkSdk.Internal.IPlayerManager.__GetInstance(__instance);
            var ___ret = __target.GetPlayer(Id);
            return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[2];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 2);
                            ManagedVTablesDtorOnly[0][1] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 5, 2);
                            ManagedVTables[0][1] = Thunks[0];
                            ManagedVTables[0][2] = Thunks[1];
                            VTables.Methods[0] = new Delegate[5];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class IPlayerManagerInternal : global::CyberpunkSdk.Internal.IPlayerManager, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IPlayerManagerInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal IPlayerManagerInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override global::CyberpunkSdk.Internal.IPlayer GetPlayer(ulong Id)
        {
            var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr_ulong>(0, 2);
            var ___ret = ___GetPlayerDelegate(__Instance, Id);
            var __result0 = global::CyberpunkSdk.Internal.IPlayer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class RpcCall : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint Id;
            internal __IntPtr Args;
            internal ulong PlayerId;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN7RpcCallC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.RpcCall> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.RpcCall>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.RpcCall managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.RpcCall managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RpcCall __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RpcCall(native.ToPointer(), skipVTables);
        }

        internal static RpcCall __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RpcCall)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RpcCall __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RpcCall(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RpcCall(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RpcCall(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RpcCall()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.RpcCall.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public RpcCall(global::CyberpunkSdk.Internal.RpcCall _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.RpcCall.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::CyberpunkSdk.Internal.RpcCall.__Internal*) __Instance) = *((global::CyberpunkSdk.Internal.RpcCall.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->Id;
            }

            set
            {
                ((__Internal*)__Instance)->Id = value;
            }
        }

        public global::CyberpunkSdk.Internal.IBuffer Args
        {
            get
            {
                var __result0 = global::CyberpunkSdk.Internal.IBuffer.__GetOrCreateInstance(((__Internal*)__Instance)->Args, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Args = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ulong PlayerId
        {
            get
            {
                return ((__Internal*)__Instance)->PlayerId;
            }

            set
            {
                ((__Internal*)__Instance)->PlayerId = value;
            }
        }
    }

    public unsafe abstract partial class IRpc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr vptr_IRpc;

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN4IRpcC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN4IRpcC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN4IRpc3GetEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IRpc> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IRpc>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IRpc managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IRpc managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IRpc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IRpcInternal(native.ToPointer(), skipVTables);
        }

        internal static IRpc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IRpc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IRpc __GetInstance(__IntPtr native)
        {
            if (!__TryGetNativeToManagedMapping(native, out var managed))
                throw new global::System.Exception("No managed instance was found");
            var result = (IRpc)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static IRpc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IRpcInternal(native, skipVTables);
        }

        protected IRpc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        protected IRpc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IRpc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IRpc");
        }

        protected IRpc(global::CyberpunkSdk.Internal.IRpc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IRpc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "CyberpunkSdk.Internal.IRpc");
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Call(ulong PlayerId, ulong Klass, ulong Function, global::CyberpunkSdk.Internal.IBuffer Arguments);

        internal abstract global::CyberpunkSdk.Internal.RpcCall GetRpc(uint aIndex);

        internal abstract void Clear();

        internal abstract uint RegisterServer(ulong Klass, ulong Function);

        internal abstract uint RegisterClient(ulong Klass, ulong Function);

        public static global::CyberpunkSdk.Internal.IRpc Get()
        {
            var ___ret = __Internal.Get();
            var __result0 = global::CyberpunkSdk.Internal.IRpc.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        internal abstract uint Count
        {
            get;
        }

        #region Virtual table interop

        // void Call(uint64_t PlayerId, uint64_t Klass, uint64_t Function, IBuffer* Arguments) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong_ulong_ulong___IntPtr _CallDelegateInstance;

        private static void _CallDelegateHook(__IntPtr __instance, ulong PlayerId, ulong Klass, ulong Function, __IntPtr Arguments)
        {
            var __target = global::CyberpunkSdk.Internal.IRpc.__GetInstance(__instance);
            var __result3 = global::CyberpunkSdk.Internal.IBuffer.__GetOrCreateInstance(Arguments, false);
            __target.Call(PlayerId, Klass, Function, __result3);
        }

        // uint32_t Count() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr _CountDelegateInstance;

        private static uint _CountDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IRpc.__GetInstance(__instance);
            var ___ret = __target.Count;
            return ___ret;
        }

        // RpcCall* GetRpc(uint32_t aIndex) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr_uint _GetRpcDelegateInstance;

        private static __IntPtr _GetRpcDelegateHook(__IntPtr __instance, uint aIndex)
        {
            var __target = global::CyberpunkSdk.Internal.IRpc.__GetInstance(__instance);
            var ___ret = __target.GetRpc(aIndex);
            return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
        }

        // void Clear() = 0
        private static global::CyberpunkSdk.Internal.Delegates.Action___IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(__IntPtr __instance)
        {
            var __target = global::CyberpunkSdk.Internal.IRpc.__GetInstance(__instance);
            __target.Clear();
        }

        // uint32_t RegisterServer(uint64_t Klass, uint64_t Function) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr_ulong_ulong _RegisterServerDelegateInstance;

        private static uint _RegisterServerDelegateHook(__IntPtr __instance, ulong Klass, ulong Function)
        {
            var __target = global::CyberpunkSdk.Internal.IRpc.__GetInstance(__instance);
            var ___ret = __target.RegisterServer(Klass, Function);
            return ___ret;
        }

        // uint32_t RegisterClient(uint64_t Klass, uint64_t Function) = 0
        private static global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr_ulong_ulong _RegisterClientDelegateInstance;

        private static uint _RegisterClientDelegateHook(__IntPtr __instance, ulong Klass, ulong Function)
        {
            var __target = global::CyberpunkSdk.Internal.IRpc.__GetInstance(__instance);
            var ___ret = __target.RegisterClient(Klass, Function);
            return ___ret;
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[6];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
            static VTableLoader()
            {
                _CallDelegateInstance += _CallDelegateHook;
                _CountDelegateInstance += _CountDelegateHook;
                _GetRpcDelegateInstance += _GetRpcDelegateHook;
                _ClearDelegateInstance += _ClearDelegateHook;
                _RegisterServerDelegateInstance += _RegisterServerDelegateHook;
                _RegisterClientDelegateInstance += _RegisterClientDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CallDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CountDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetRpcDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_RegisterServerDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_RegisterClientDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8, 2);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            VTables.Methods[0] = new Delegate[8];
                            if (destructorOnly)
                                return VTables;
                        }
                    }
                }

                *(IntPtr**)(instance + 0) = ManagedVTables[0];
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        {
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {
                __vtables = value;
            }
        }
        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class IRpcInternal : global::CyberpunkSdk.Internal.IRpc, IDisposable
    {
        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IRpcInternal(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        internal IRpcInternal(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public override void Call(ulong PlayerId, ulong Klass, ulong Function, global::CyberpunkSdk.Internal.IBuffer Arguments)
        {
            var ___CallDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr_ulong_ulong_ulong___IntPtr>(0, 0);
            var __arg3 = Arguments is null ? __IntPtr.Zero : Arguments.__Instance;
            ___CallDelegate(__Instance, PlayerId, Klass, Function, __arg3);
        }

        internal override global::CyberpunkSdk.Internal.RpcCall GetRpc(uint aIndex)
        {
            var ___GetRpcDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func___IntPtr___IntPtr_uint>(0, 2);
            var ___ret = ___GetRpcDelegate(__Instance, aIndex);
            var __result0 = global::CyberpunkSdk.Internal.RpcCall.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        internal override void Clear()
        {
            var ___ClearDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Action___IntPtr>(0, 3);
            ___ClearDelegate(__Instance);
        }

        internal override uint RegisterServer(ulong Klass, ulong Function)
        {
            var ___RegisterServerDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr_ulong_ulong>(0, 4);
            var ___ret = ___RegisterServerDelegate(__Instance, Klass, Function);
            return ___ret;
        }

        internal override uint RegisterClient(ulong Klass, ulong Function)
        {
            var ___RegisterClientDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr_ulong_ulong>(0, 5);
            var ___ret = ___RegisterClientDelegate(__Instance, Klass, Function);
            return ___ret;
        }

        internal override uint Count
        {
            get
            {
                var ___CountDelegate = __VTables.GetMethodDelegate<global::CyberpunkSdk.Internal.Delegates.Func_uint___IntPtr>(0, 1);
                var ___ret = ___CountDelegate(__Instance);
                return ___ret;
            }
        }
    }

    public unsafe partial class IWorld : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN6IWorldC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Server.Native", EntryPoint = "_ZN6IWorld3GetEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IWorld> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CyberpunkSdk.Internal.IWorld>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CyberpunkSdk.Internal.IWorld managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CyberpunkSdk.Internal.IWorld managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IWorld __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new IWorld(native.ToPointer(), skipVTables);
        }

        internal static IWorld __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IWorld)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IWorld __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IWorld(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IWorld(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected IWorld(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public IWorld()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IWorld.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public IWorld(global::CyberpunkSdk.Internal.IWorld _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CyberpunkSdk.Internal.IWorld.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::CyberpunkSdk.Internal.IWorld.__Internal*) __Instance) = *((global::CyberpunkSdk.Internal.IWorld.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static global::CyberpunkSdk.Internal.IWorld Get()
        {
            var ___ret = __Internal.Get();
            var __result0 = global::CyberpunkSdk.Internal.IWorld.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate ulong Func_ulong___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate sbyte Func_sbyte___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate byte Func_byte___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate short Func_short___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate ushort Func_ushort___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate long Func_long___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_sbyte(__IntPtr __instance, sbyte arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_byte(__IntPtr __instance, byte arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_short(__IntPtr __instance, short arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ushort(__IntPtr __instance, ushort arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_long(__IntPtr __instance, long arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_float(__IntPtr __instance, float arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_bool(__IntPtr __instance, [MarshalAs(UnmanagedType.I1)] bool arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::CyberpunkSdk.Internal.Vector3.__Internal Func_CyberpunkSdk_Internal_Vector3___Internal___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong_ulong___IntPtr(__IntPtr __instance, ulong arg1, ulong arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong_ulong_ulong___IntPtr(__IntPtr __instance, ulong arg1, ulong arg2, ulong arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint___IntPtr_ulong_ulong(__IntPtr __instance, ulong arg1, ulong arg2);
    }
}
